# ZooKeeper 分布式锁实现方案讨论

## 一、核心原理

### 1.1 ZooKeeper 的特性优势

ZooKeeper 实现分布式锁主要利用以下特性：

1. **临时节点（Ephemeral Nodes）**
   - 节点生命周期与客户端会话绑定
   - 客户端断开连接时，节点自动删除
   - **关键作用**：避免死锁，自动释放锁

2. **序列节点（Sequential Nodes）**
   - 创建时自动在路径末尾附加单调递增的计数器
   - 例如：`/lock/node_0000000001`、`/lock/node_0000000002`
   - **关键作用**：实现公平锁（FIFO 队列）

3. **Watches 机制**
   - 客户端可以在节点上设置监听
   - 节点变化时（创建、删除、数据变更）触发通知
   - **关键作用**：实现阻塞等待和唤醒机制

4. **强一致性**
   - ZooKeeper 保证数据的一致性和顺序性
   - **关键作用**：确保锁的正确性，不会出现多个客户端同时持有锁

## 二、实现模式

### 2.1 模式一：简单互斥锁（基于临时节点）

**实现思路：**
```
1. 所有客户端尝试在同一路径下创建临时节点：/lock/resource
2. 只有一个客户端能成功创建（ZooKeeper 保证节点唯一性）
3. 成功的客户端获得锁
4. 失败的客户端在该节点上设置 watch，等待节点删除
5. 持有锁的客户端完成任务后，删除节点或断开连接
6. 节点删除触发 watch，等待的客户端被唤醒，重新竞争
```

**优点：**
- 实现简单
- 自动释放（会话断开时）

**缺点：**
- 非公平锁（后到的客户端可能先获得锁）
- 惊群效应（所有等待客户端同时被唤醒，但只有一个能获得锁）

### 2.2 模式二：公平锁（基于序列节点 + Watch）

**实现思路：**
```
1. 所有客户端在 /lock 下创建序列临时节点：
   - Client A: /lock/node_0000000001
   - Client B: /lock/node_0000000002
   - Client C: /lock/node_0000000003

2. 每个客户端检查自己创建的节点是否为最小序列号
   - 如果是，获得锁
   - 如果不是，监听前一个节点（比自己序列号小1的节点）

3. 当前持有锁的客户端完成任务后，删除自己的节点

4. 下一个节点收到 watch 通知，检查自己是否为最小序列号
   - 如果是，获得锁
   - 如果不是，继续等待
```

**优点：**
- 公平锁（FIFO 队列，先到先得）
- 避免惊群效应（每次只有一个客户端被唤醒）
- 自动释放

**缺点：**
- 实现相对复杂
- 需要维护节点序列

### 2.3 模式三：可重入锁（Reentrant Lock）

**实现思路：**
```
1. 在节点数据中存储锁的持有者信息（线程ID、进程ID等）
2. 获取锁时，检查当前线程是否已经持有锁
3. 如果已持有，增加重入计数
4. 释放锁时，减少重入计数，只有计数为0时才真正释放
```

**优点：**
- 支持同一线程多次获取锁
- 避免死锁

**缺点：**
- 实现更复杂
- 需要维护重入计数

### 2.4 模式四：读写锁（Read-Write Lock）

**实现思路：**
```
1. 读锁：多个客户端可以同时持有
   - 创建序列节点，节点数据标记为 "read"
   - 检查前面是否有写锁节点，如果没有则获得读锁

2. 写锁：独占锁
   - 创建序列节点，节点数据标记为 "write"
   - 检查自己是否为最小序列号，如果是则获得写锁

3. 读锁之间不互斥，读锁与写锁互斥，写锁之间互斥
```

**优点：**
- 提高并发性能（读多写少场景）
- 保证数据一致性

**缺点：**
- 实现复杂
- 需要区分读写操作

## 三、业界主流实现方案

### 3.1 Apache Curator 的 InterProcessMutex

**Curator 是 Netflix 开源的 ZooKeeper 客户端框架，提供了现成的分布式锁实现。**

**核心类：**
- `InterProcessMutex` - 可重入互斥锁
- `InterProcessSemaphoreMutex` - 不可重入互斥锁
- `InterProcessReadWriteLock` - 读写锁
- `InterProcessMultiLock` - 多锁（同时获取多个锁）

**实现原理：**
```java
// Curator 使用模式二（公平锁）实现
// 1. 在 /lock 下创建序列临时节点
// 2. 检查是否为最小序列号
// 3. 如果不是，监听前一个节点
// 4. 支持可重入（在节点数据中存储线程信息）
```

**使用示例：**
```java
InterProcessMutex lock = new InterProcessMutex(client, "/lock/resource");
try {
    // 尝试获取锁，最多等待10秒
    if (lock.acquire(10, TimeUnit.SECONDS)) {
        try {
            // 执行业务逻辑
            doSomething();
        } finally {
            // 释放锁
            lock.release();
        }
    }
} catch (Exception e) {
    // 处理异常
}
```

**优点：**
- 生产级实现，经过大量验证
- 支持可重入
- 自动处理连接断开、会话过期等异常
- 提供多种锁类型

### 3.2 其他实现方案

**1. 原生 ZooKeeper API 实现**
- 直接使用 ZooKeeper 客户端 API
- 需要自己处理所有细节（重试、watch、异常处理等）
- 不推荐，除非有特殊需求

**2. 基于 Curator Recipes 的自定义实现**
- 使用 Curator 的基础功能
- 根据业务需求定制锁的行为
- 适合有特殊需求的场景

## 四、关键问题和解决方案

### 4.1 会话过期问题

**问题：**
- 客户端与 ZooKeeper 连接断开
- 会话过期，临时节点被删除
- 但客户端可能仍在执行业务逻辑

**解决方案：**
1. **心跳机制**：定期发送心跳保持会话活跃
2. **锁续期**：在业务逻辑执行期间，定期续期锁
3. **业务幂等性**：确保业务逻辑可以安全重试

### 4.2 网络分区问题

**问题：**
- 客户端与 ZooKeeper 集群网络分区
- 客户端认为持有锁，但 ZooKeeper 已删除节点
- 其他客户端可能获得锁

**解决方案：**
1. **使用 Fencing Token**：在锁节点数据中存储递增的 token
2. **业务层验证**：在执行业务前验证 token 是否有效
3. **超时机制**：设置合理的锁超时时间

### 4.3 性能优化

**问题：**
- 大量客户端竞争同一把锁
- Watch 通知可能延迟

**解决方案：**
1. **锁粒度细化**：将大锁拆分为多个小锁
2. **异步通知**：使用异步 watch 减少阻塞
3. **连接池**：复用 ZooKeeper 连接

## 五、与其他方案对比

### 5.1 vs Redis 分布式锁

| 特性 | ZooKeeper | Redis |
|------|-----------|-------|
| **一致性** | 强一致性（CP） | 最终一致性（AP） |
| **性能** | 相对较慢（需要持久化） | 较快（内存操作） |
| **可靠性** | 高（自动释放） | 需要设置过期时间 |
| **公平性** | 天然支持（序列节点） | 需要额外实现 |
| **复杂度** | 中等 | 较低 |
| **适用场景** | 对一致性要求高的场景 | 对性能要求高的场景 |

### 5.2 vs 数据库分布式锁

| 特性 | ZooKeeper | 数据库 |
|------|-----------|--------|
| **性能** | 中等 | 较慢 |
| **可靠性** | 高 | 中等 |
| **死锁处理** | 自动（临时节点） | 需要超时机制 |
| **扩展性** | 好 | 一般 |
| **适用场景** | 分布式协调 | 简单场景 |

## 六、最佳实践

### 6.1 锁的命名规范

```
/lock/{业务模块}/{资源类型}/{资源ID}
例如：
/lock/order/payment/1001
/lock/inventory/stock/2001
```

### 6.2 锁超时设置

- **获取锁超时**：根据业务场景设置，一般 5-30 秒
- **锁持有时间**：尽量短，避免长时间占用
- **会话超时**：ZooKeeper 默认 40 秒，可根据网络情况调整

### 6.3 异常处理

```java
try {
    if (lock.acquire(timeout, TimeUnit.SECONDS)) {
        try {
            // 业务逻辑
        } finally {
            lock.release();
        }
    }
} catch (KeeperException e) {
    // ZooKeeper 异常处理
} catch (InterruptedException e) {
    // 中断异常处理
    Thread.currentThread().interrupt();
}
```

### 6.4 监控和告警

- 监控锁的获取时间
- 监控锁的等待队列长度
- 监控锁的持有时间
- 告警锁竞争激烈的情况

## 七、适用场景

### 7.1 适合使用 ZooKeeper 分布式锁的场景

1. **对一致性要求高**：如金融交易、库存扣减
2. **需要公平锁**：如任务调度、资源分配
3. **需要自动释放**：避免死锁的场景
4. **已有 ZooKeeper 集群**：不需要额外引入 Redis

### 7.2 不适合使用的场景

1. **高并发、低一致性要求**：如计数器、限流
2. **对性能要求极高**：如缓存更新
3. **简单场景**：可以用数据库锁解决

## 八、总结

ZooKeeper 分布式锁的核心优势：
- ✅ **强一致性**：保证锁的正确性
- ✅ **自动释放**：避免死锁
- ✅ **公平性**：支持 FIFO 队列
- ✅ **可靠性**：经过生产验证

业界推荐使用 **Apache Curator** 的 `InterProcessMutex`，它：
- 提供了生产级的实现
- 处理了各种边界情况
- 支持可重入、读写锁等高级特性
- 有完善的异常处理机制

对于大多数场景，直接使用 Curator 的实现即可，无需自己实现。
